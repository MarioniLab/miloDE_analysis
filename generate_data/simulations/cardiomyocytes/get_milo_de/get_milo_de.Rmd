---
title: "Run miloDE for different neighbourhood assignements of simulated data."
output:
  BiocStyle::html_document:
    code_folding: hide
    number_sections: yes
    toc: yes  
---
# Load dependencies

```{r load, message = FALSE}


library(SingleCellExperiment)
library(batchelor)
library(stats)
library(BiocNeighbors)
library(tibble)
library(reshape2)
library(plyr)
library(dplyr)
library(scran)
library(stringr)
library(Seurat)
library(irlba)
library(igraph)
library(miloR)
library(ggplot2)
library(scater)
library(scran)
library(Matrix)
library(splatter)
library(BiocParallel)
library(BiocSingular)
library(miloR)
library(miloDE)
library(S4Vectors)
library(slingshot)

ncores = 25
mcparam = MulticoreParam(workers = ncores)
register(mcparam)

set.seed(32)

root.dir = "/nfs/research/marioni/alsu/hubmap_metaRef/"

simulated_genes = readRDS(file = paste0(root.dir , "data/processed/simulations/brain/simulated_genes.Rds"))
sces = readRDS(paste0(root.dir , "data/processed/simulations/cardiomyocytes/sces_simulated.Rds"))


sce = readRDS(paste0(root.dir , "data/sces/mouse_embryo/chimera_WT/mouse_embryo_wt_chimera.Rds"))
sce = sce[, sce$celltype == "Cardiomyocytes"]
set.seed(32)
slingshot_res <- slingPseudotime(slingshot(as.matrix(reducedDim(sce , "mnn_unsupervised_wt"))))
sce$pt = as.numeric(slingshot_res)
pt_grid = sapply(seq(0,1,0.01) , function(i) return(as.numeric(quantile(sce$pt , i))))

cluster_splits = list(c(pt_grid[1] , pt_grid[3]) , 
                      c(pt_grid[49] , pt_grid[51]),
                      c(pt_grid[99] , pt_grid[101]),
                      c(pt_grid[1] , pt_grid[6]) , 
                      c(pt_grid[47] , pt_grid[53]),
                      c(pt_grid[95] , pt_grid[101]),
                      c(pt_grid[1] , pt_grid[11]) , 
                      c(pt_grid[45] , pt_grid[55]),
                      c(pt_grid[91] , pt_grid[101]),
                      c(pt_grid[1] , pt_grid[26]) , 
                      c(pt_grid[37] , pt_grid[63]),
                      c(pt_grid[75] , pt_grid[101])
                      )


```

# Functions

```{r functions, message = FALSE}



get_de_selected_genes = function(sce_milo , genes){
 
  current.nhoods = nhoods(sce_milo)
  subset_nhoods = c(1:ncol(current.nhoods))
  
  de_stat = bplapply(seq(length(subset_nhoods)) , function(i){
    print(i)
    hood_id = subset_nhoods[i]
    out = de_test_single_neighbourhood(sce_milo , nhoods_x = current.nhoods, hood_id = hood_id,
                                           sample_id = "sample", design = ~type, covariates = c("type"), contrasts = NULL,
                                           min_n_cells_per_sample = 1 ,
                                           min_count = 1 , run_separately = T)
    out = out[out$gene %in% genes , ]
    return(out)
  }, BPPARAM = mcparam)
  
  # put together in SCE format
  de_stat_sce = SingleCellExperiment(list(logFC = matrix(NA, nrow = nrow(sce_milo), ncol = length(subset_nhoods)) ,
                                            pval = matrix(NA, nrow = nrow(sce_milo), ncol = length(subset_nhoods)) ,
                                            pval_corrected_across_genes = matrix(NA, nrow = nrow(sce_milo), ncol = length(subset_nhoods))))
  rownames(de_stat_sce) = rownames(sce_milo)
  for (i in seq(length(de_stat))){
    current.de_stat = de_stat[[i]]
    assay(de_stat_sce , "logFC")[current.de_stat$gene , i] = current.de_stat$logFC
    assay(de_stat_sce , "pval")[current.de_stat$gene , i] = current.de_stat$pval
    assay(de_stat_sce , "pval_corrected_across_genes")[current.de_stat$gene , i] = current.de_stat$pval_corrected_across_genes
  }

  # add coldata on nhoods
  meta_nhoods = lapply(seq(length(de_stat)) , function(i){
    current.de_stat = de_stat[[i]]
    current.meta = unique(current.de_stat[, c("Nhood" , "Nhood_center" , "test_performed" )])
    return(current.meta)
  })
  meta_nhoods = do.call(rbind , meta_nhoods)
  colData(de_stat_sce) = DataFrame(meta_nhoods)
  colnames(de_stat_sce) = meta_nhoods$Nhood
  
  # select genes w at least one test
  idx = which( rowMeans(is.na(assay(de_stat_sce , "pval"))) < 1)
  de_stat_sce = de_stat_sce[idx , ]
  
  # pval correction
  pval_corrected = bplapply(rownames(de_stat_sce) , function(gene){
    pvals = assay(de_stat_sce , "pval")[gene , ]
    out = miloDE::spatial_pval_adjustment(nhoods_x = as.matrix(current.nhoods[,subset_nhoods]) , pvalues = pvals)
    return(out)
  } , BPPARAM = mcparam)

  # add the assay into final de-stat
  assay_pval_corrected_across_nhoods = do.call(rbind , pval_corrected)
  rownames(assay_pval_corrected_across_nhoods) = rownames(de_stat_sce)
  colnames(assay_pval_corrected_across_nhoods) = colnames(de_stat_sce)
  assay(de_stat_sce , "pval_corrected_across_nhoods") = assay_pval_corrected_across_nhoods
  
  # convert to data.frame
  de_stat = convert_de_stat(de_stat_sce)
  return(de_stat)
}


add_da = function(sce_milo , reducedDim_name , sample_id = "sample", condition_id , col_annotate , covariates = NULL){
  require(dplyr)
  require(miloR)
  coldata <- as.data.frame(colData(sce_milo))
  sce_milo$condition_id <- as.factor( coldata[, condition_id] )
  sce_milo$sample_id <- as.factor( coldata[, sample_id] )
  
  sce_milo <- countCells(sce_milo, meta.data = as.data.frame(colData(sce_milo)), samples="sample_id")
  sce_design <- data.frame(colData(sce_milo))[,c("sample_id", "condition_id" , covariates)]
  sce_design <- distinct(sce_design)
  rownames(sce_design) <- sce_design$sample_id
  nhoodCounts(sce_milo) = as.matrix(nhoodCounts(sce_milo) , "dgCMatrix")
  

  if (!is.null(covariates)){
    da_results = tryCatch(
      {
        out = testNhoods(sce_milo, design = as.formula( paste("~ ", paste(covariates, collapse="+"),sep = "" , " + condition_id") ) , design.df = sce_design, fdr.weighting = "graph-overlap", reduced.dim = reducedDim_name)
        
      },
      error = function(dummy){
        out = testNhoods(sce_milo, design = ~ factor(condition_id), design.df = sce_design, fdr.weighting = "graph-overlap", reduced.dim = reducedDim_name)
        out$logFC = NaN
        out$logCPM = NaN
        out[, "F"] = NaN
        out$PValue = NaN
        out$FDR = NaN
        out$SpatialFDR = NaN
        return(out)
      }
    )
  }
  else {
    da_results <- testNhoods(sce_milo, design = ~ factor(condition_id), design.df = sce_design, fdr.weighting = "graph-overlap", reduced.dim = reducedDim_name)
  }
  if (!is.null(col_annotate)){
    da_results = annotateNhoods(sce_milo, da_results, coldata_col = col_annotate)
  }
  da_results = da_results[order(da_results$Nhood) , ]
  return(da_results)
}


add_stat = function(sce_milo){
  stat_da = add_da(sce_milo , reducedDim_name = "mnn_unsupervised_wt" , sample_id = "sample", condition_id = "type", col_annotate = NULL)
  stat_da = stat_da[, c("Nhood", "logFC" , "SpatialFDR" )]
  colnames(stat_da) = c("Nhood", "logFC_DA" , "SpatialFDR_DA" )
  
  nhoods_sce = nhoods(sce_milo)
  nhood_stat = data.frame(Nhood = 1:ncol(nhoods_sce) , 
                          n_hoods = ncol(nhoods_sce),
                          avg_hood_size = mean(colSums(nhoods_sce)),
                          hood_size = colSums(nhoods_sce)
                          )
  stat_da = merge(stat_da , nhood_stat , all.x = T , all.y = F)
  # get cluster purity
  stat_da$cluster_purity = sapply(1:ncol(nhoods_sce) , function(i){
    current.cells = which(nhoods_sce[,i] == 1)
    current.cells = rownames(nhoods_sce)[current.cells]
    out = mean(current.cells %in% sce_milo$cell[sce_milo$perturbed == T])
    return(out)
  })
  
  return(stat_da)
}


```

# Run miloDE

## Original embedding

```{r milo-de-orginal, message = FALSE}


anno = expand.grid(order = 2, k = seq(15,30,5), prop = c(0.1), round = c(1:3))
anno$id = paste0(anno$order , "_" , anno$k , "_" , anno$round)

# We wont be saving this coz its easy to recalc and it weights a lot
sces_milo = lapply(sces , function(sce){
  sce_milo = bplapply(1:nrow(anno) , function(i){
    set.seed(anno$round[i])
    out = miloDE::assign_neighbourhoods(sce , k = anno$k[i], prop = anno$prop[i] , order = anno$order[i] , reducedDim_name = "mnn_unsupervised_wt" , filtering = T)
    return(out)
  }, BPPARAM = mcparam)
  return(sce_milo)
})


stat = lapply(1:length(sces_milo) , function(j){
  sce_milo = sces_milo[[j]]
  stat_per_sce = lapply(1:nrow(anno) , function(i){
    current.sce = sce_milo[[i]]
    current.sce$perturbed = current.sce$pt >= cluster_splits[[j]][1] & current.sce$pt <= cluster_splits[[j]][2]
    rowdata = as.data.frame(rowData(current.sce))
  
    stat_de = get_de_selected_genes(current.sce , genes = simulated_genes$ENSEMBL)
    colnames(stat_de)[colnames(stat_de) == "gene"] = "ENSEMBL"
    stat_de = merge(stat_de , rowdata , all.x = T)
    
    milo_stat = add_stat(current.sce)
    stat_de = merge(stat_de , milo_stat , all.x = T)
    
    stat_de = cbind(stat_de , anno[i , c("order" , "k" , "round" , "id")])
    return(stat_de)
  })
  stat_per_sce = do.call(rbind , stat_per_sce)
  return(stat_per_sce)
})
saveRDS(stat , file = paste0(root.dir , "data/processed/simulations/cardiomyocytes/milo_de_stat__original_embedding.Rds"))



```

## Re-calculated embedding

```{r milo-de-recal, message = FALSE}



anno = expand.grid(order = 2, k = seq(15,30,5), prop = c(0.1), round = c(1:3))
anno$id = paste0(anno$order , "_" , anno$k , "_" , anno$round)

# We wont be saving this coz its easy to recalc and it weights a lot
sces_milo = lapply(sces , function(sce){
  sce_milo = bplapply(1:nrow(anno) , function(i){
    set.seed(anno$round[i])
    out = miloDE::assign_neighbourhoods(sce , k = anno$k[i], prop = anno$prop[i] , order = anno$order[i] , reducedDim_name = "pca.simulations" , filtering = T)
    return(out)
  }, BPPARAM = mcparam)
  return(sce_milo)
})


stat = lapply(1:length(sces_milo) , function(j){
  sce_milo = sces_milo[[j]]
  stat_per_sce = lapply(1:nrow(anno) , function(i){
    current.sce = sce_milo[[i]]
    current.sce$perturbed = current.sce$pt >= cluster_splits[[j]][1] & current.sce$pt <= cluster_splits[[j]][2]
    rowdata = as.data.frame(rowData(current.sce))
  
    stat_de = get_de_selected_genes(current.sce , genes = simulated_genes$ENSEMBL)
    colnames(stat_de)[colnames(stat_de) == "gene"] = "ENSEMBL"
    stat_de = merge(stat_de , rowdata , all.x = T)
    
    milo_stat = add_stat(current.sce)
    stat_de = merge(stat_de , milo_stat , all.x = T)
    
    stat_de = cbind(stat_de , anno[i , c("order" , "k" , "round" , "id")])
    return(stat_de)
  })
  stat_per_sce = do.call(rbind , stat_per_sce)
  return(stat_per_sce)
})
saveRDS(stat , file = paste0(root.dir , "data/processed/simulations/cardiomyocytes/milo_de_stat__recalculated_embedding.Rds"))



```


# Session Info

```{r sessinf}
sessionInfo()
```
